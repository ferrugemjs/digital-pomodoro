{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/ferrugemjs/dist/core/component-factory.js","webpack:///./node_modules/incremental-dom/dist/incremental-dom-cjs.js","webpack:///./node_modules/ferrugemjs/dist/core/nodes-watched.js","webpack:///./node_modules/ferrugemjs/dist/core/platform.js","webpack:///./app/main.js","webpack:///./node_modules/ferrugemjs/dist/core/index.js","webpack:///./node_modules/ferrugemjs/dist/core/nodes-action.js","webpack:///./node_modules/ferrugemjs/dist/core/bootstrapper.js"],"names":["webpackJsonpCallback","data","moduleId","chunkId","chunkIds","moreModules","i","resolves","length","installedChunks","push","Object","prototype","hasOwnProperty","call","modules","parentJsonpFunction","shift","installedModules","1","__webpack_require__","exports","module","l","e","promises","installedChunkData","promise","Promise","resolve","reject","onScriptComplete","head","document","getElementsByTagName","script","createElement","charset","timeout","nc","setAttribute","src","p","jsonpScriptSrc","event","onerror","onload","clearTimeout","chunk","errorType","type","realSrc","target","error","Error","request","undefined","setTimeout","appendChild","all","m","c","d","name","getter","o","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","oe","err","console","jsonpArray","window","oldJsonpFunction","slice","s","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","require","_IDOM","nodes_watched_1","nodes_action_1","uid_generated","Date","getTime","notifications","nodesDeleted","nodes","forEach","detacheNode","nodesCreated","attacheNode","attributes","el","checked","ComponentFactory","this","config","templateExtension","build","_key","hostVars","staticVars","_prop_values","keyp","classFactory","refresh","default","_prop_","indexOf","changeAttrs","inst","_capture$KeyId","p_key","alias","tag","extHostVars","extStaticVars","assign","content","$content$","_$content$_","attrs_vars","isStatics","forbiddenAttrList","_loop_1","propOrign","prop","toLowerCase","replace","match","group1","toUpperCase","newValue","test","attrcondi","this_1","prop_splited","split","compInst_1","_$unsubs$_","afterDetached","insSub","unsubscribeAll","compName","warn","oldValue","attributeChanged","reDraw","_$key$_","_inst_","elementOpen","apply","concat","Function","render","elementClose","props","shouldUpdate","handlerRefresh","propsResolved","loaded","getElementById","elementDom_1","converted_to_array_1","attrkey","$indx","patch","then","compose","path","host_vars","static_vars","contentfn","_this","__WEBPACK_AMD_REQUIRE_ARRAY__","mod","substring","lastIndexOf","attached","body","querySelector","catch","Blank","has","map","createMap","initData","node","nodeName","attrs","attrsArr","newAttrs","staticsApplied","keyMap","keyMapValid","focused","text","getData","importNode","isElement","Element","localName","getAttribute","parentNode","attr","child","firstChild","nextSibling","doc","parent","namespace","namespaceURI","getNamespaceForTag","createElementNS","Context","created","deleted","markCreated","markDeleted","notifyChanges","getActiveElement","root","cur","prev","getRoot","Document","DocumentFragment","isDocumentRoot","activeElement","context","currentNode","currentParent","markFocused","focusPath","patchFactory","run","fn","prevContext","prevDoc","prevCurrentNode","prevCurrentParent","ownerDocument","contains","ancestry","getAncestry","getFocusedPath","retVal","patchInner","enterNode","exitNode","patchOuter","startNode","removeChild","matches","matchNode","alignWithDOM","parentData","currentNodeData","keyNode","createTextNode","createText","referenceNode","insertReferenceNode","next","insertBefore","moveBefore","replaceChild","getNextNode","nextNode","lastChild","clearUnvisitedDOM","skipNode","symbols","applyAttr","removeAttribute","attrNS","getNamespace","setAttributeNS","applyProp","setStyleValue","style","setProperty","updateAttribute","cssText","elStyle","obj","argsBuilder","statics","var_args","coreElementOpen","_i","isNew","j","arguments","_attr","_attr2","currentElement","currentPointer","skip","elementVoid","elementOpenStart","elementOpenEnd","formatted","component_factory_1","PlatformBootstrap","bootstrap","pmodule","option","_module","at","domRender","app_uid","_tmp_inst","key:id","bootstrapper","platform_1","bootstrapper_1","componentFactory","platform","children","Array","key_id","inst_captured","detached","app_html","app_html_s","querySelectorAll","app_url","_mod_init_app"],"mappings":"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","file":"bundle.js","sourcesContent":[" \t// install a JSONP callback for chunk loading\n \tfunction webpackJsonpCallback(data) {\n \t\tvar chunkIds = data[0];\n \t\tvar moreModules = data[1];\n\n\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, resolves = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(installedChunks[chunkId]) {\n \t\t\t\tresolves.push(installedChunks[chunkId][0]);\n \t\t\t}\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(data);\n\n \t\twhile(resolves.length) {\n \t\t\tresolves.shift()();\n \t\t}\n\n \t};\n\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \t// undefined = chunk not loaded, null = chunk preloaded/prefetched\n \t// Promise = chunk loading, 0 = chunk loaded\n \tvar installedChunks = {\n \t\t1: 0\n \t};\n\n\n\n \t// script path function\n \tfunction jsonpScriptSrc(chunkId) {\n \t\treturn __webpack_require__.p + \"\" + chunkId + \".bundle.js\"\n \t}\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n \t// This file contains only the entry chunk.\n \t// The chunk loading function for additional chunks\n \t__webpack_require__.e = function requireEnsure(chunkId) {\n \t\tvar promises = [];\n\n\n \t\t// JSONP chunk loading for javascript\n\n \t\tvar installedChunkData = installedChunks[chunkId];\n \t\tif(installedChunkData !== 0) { // 0 means \"already installed\".\n\n \t\t\t// a Promise means \"currently loading\".\n \t\t\tif(installedChunkData) {\n \t\t\t\tpromises.push(installedChunkData[2]);\n \t\t\t} else {\n \t\t\t\t// setup Promise in chunk cache\n \t\t\t\tvar promise = new Promise(function(resolve, reject) {\n \t\t\t\t\tinstalledChunkData = installedChunks[chunkId] = [resolve, reject];\n \t\t\t\t});\n \t\t\t\tpromises.push(installedChunkData[2] = promise);\n\n \t\t\t\t// start chunk loading\n \t\t\t\tvar head = document.getElementsByTagName('head')[0];\n \t\t\t\tvar script = document.createElement('script');\n \t\t\t\tvar onScriptComplete;\n\n \t\t\t\tscript.charset = 'utf-8';\n \t\t\t\tscript.timeout = 120;\n \t\t\t\tif (__webpack_require__.nc) {\n \t\t\t\t\tscript.setAttribute(\"nonce\", __webpack_require__.nc);\n \t\t\t\t}\n \t\t\t\tscript.src = jsonpScriptSrc(chunkId);\n\n \t\t\t\tonScriptComplete = function (event) {\n \t\t\t\t\t// avoid mem leaks in IE.\n \t\t\t\t\tscript.onerror = script.onload = null;\n \t\t\t\t\tclearTimeout(timeout);\n \t\t\t\t\tvar chunk = installedChunks[chunkId];\n \t\t\t\t\tif(chunk !== 0) {\n \t\t\t\t\t\tif(chunk) {\n \t\t\t\t\t\t\tvar errorType = event && (event.type === 'load' ? 'missing' : event.type);\n \t\t\t\t\t\t\tvar realSrc = event && event.target && event.target.src;\n \t\t\t\t\t\t\tvar error = new Error('Loading chunk ' + chunkId + ' failed.\\n(' + errorType + ': ' + realSrc + ')');\n \t\t\t\t\t\t\terror.type = errorType;\n \t\t\t\t\t\t\terror.request = realSrc;\n \t\t\t\t\t\t\tchunk[1](error);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tinstalledChunks[chunkId] = undefined;\n \t\t\t\t\t}\n \t\t\t\t};\n \t\t\t\tvar timeout = setTimeout(function(){\n \t\t\t\t\tonScriptComplete({ type: 'timeout', target: script });\n \t\t\t\t}, 120000);\n \t\t\t\tscript.onerror = script.onload = onScriptComplete;\n \t\t\t\thead.appendChild(script);\n \t\t\t}\n \t\t}\n \t\treturn Promise.all(promises);\n \t};\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// on error function for async loading\n \t__webpack_require__.oe = function(err) { console.error(err); throw err; };\n\n \tvar jsonpArray = window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || [];\n \tvar oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\n \tjsonpArray.push = webpackJsonpCallback;\n \tjsonpArray = jsonpArray.slice();\n \tfor(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);\n \tvar parentJsonpFunction = oldJsonpFunction;\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 6);\n","define([\"require\", \"exports\", \"incremental-dom\", \"./nodes-watched\", \"./nodes-action\"], function (require, exports, _IDOM, nodes_watched_1, nodes_action_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var uid_generated = new Date().getTime() + 1298;\n    _IDOM.notifications.nodesDeleted = function (nodes) {\n        nodes.forEach(nodes_action_1.detacheNode);\n    };\n    _IDOM.notifications.nodesCreated = function (nodes) {\n        nodes.forEach(nodes_action_1.attacheNode);\n    };\n    _IDOM.attributes.value = function (el, name, value) {\n        el.value = value === null || typeof (value) === 'undefined' ? '' : value;\n    };\n    _IDOM.attributes.checked = function (el, name, value) {\n        el.checked = !!value;\n    };\n    var ComponentFactory = (function () {\n        function ComponentFactory() {\n            this.config = { templateExtension: '.html' };\n        }\n        ComponentFactory.prototype.build = function (config) {\n            var _key = config.target;\n            if (config.hostVars && config.hostVars['key:id']) {\n                _key = config.hostVars['key:id'];\n                delete config.hostVars['key:id'];\n            }\n            else if (config.staticVars && config.staticVars['key:id']) {\n                _key = config.staticVars['key:id'];\n                delete config.staticVars['key:id'];\n            }\n            if (config.hostVars && config.hostVars['prop:values']) {\n                var _prop_values = config.hostVars['prop:values'];\n                delete config.hostVars['prop:values'];\n                for (var keyp in _prop_values) {\n                    config.hostVars[keyp] = _prop_values[keyp];\n                }\n            }\n            else if (config.staticVars && config.staticVars['prop:values']) {\n                delete config.staticVars['prop:values'];\n            }\n            if (!config.classFactory.prototype.refresh) {\n                config.classFactory.prototype.refresh = ComponentFactory.prototype.refresh;\n            }\n            if (_key && nodes_watched_1.default[_key]) {\n                if (config.hostVars) {\n                    for (var _prop_ in config.hostVars) {\n                        if (_prop_.indexOf('.') > -1) {\n                            delete config.hostVars[_prop_];\n                        }\n                    }\n                }\n                this.changeAttrs.call(nodes_watched_1.default[_key].inst, config.hostVars);\n                return nodes_watched_1.default[_key].inst;\n            }\n            nodes_watched_1.default[_key] = { inst: new config.classFactory() };\n            nodes_watched_1.default[_key].target = config.target;\n            if (!nodes_watched_1.default[_key].inst._capture$KeyId) {\n                (function (p_key) {\n                    nodes_watched_1.default[_key].inst._capture$KeyId = function () {\n                        return p_key;\n                    };\n                }(_key));\n            }\n            nodes_watched_1.default[_key].alias = config.alias;\n            nodes_watched_1.default[_key].tag = config.tag || 'div';\n            nodes_watched_1.default[_key].tag = nodes_watched_1.default[_key].inst['_$attrs$_'] ? nodes_watched_1.default[_key].inst['_$attrs$_']['name'] : nodes_watched_1.default[_key].tag;\n            this.changeAttrs.call(nodes_watched_1.default[_key].inst, config.hostVars);\n            this.changeAttrs.call(nodes_watched_1.default[_key].inst, config.staticVars);\n            if (nodes_watched_1.default[_key].inst['_$attrs$_']) {\n                nodes_watched_1.default[_key].extHostVars = nodes_watched_1.default[_key].inst['_$attrs$_']['dinamic'];\n                nodes_watched_1.default[_key].extStaticVars = Object.assign([], nodes_watched_1.default[_key].inst['_$attrs$_']['static']);\n            }\n            return nodes_watched_1.default[_key].inst;\n        };\n        ComponentFactory.prototype.content = function ($content$) {\n            if ($content$) {\n                this._$content$_ = $content$;\n            }\n            else if (this._$content$_) {\n                this._$content$_();\n            }\n            return this;\n        };\n        ComponentFactory.prototype.changeAttrs = function (attrs_vars, isStatics) {\n            if (attrs_vars) {\n                var forbiddenAttrList = ['key-id', 'is'];\n                var _loop_1 = function (propOrign) {\n                    if (forbiddenAttrList.indexOf(propOrign) < 0) {\n                        var notAccepted = isStatics && (propOrign === 'id' || propOrign === 'is');\n                        if (!notAccepted) {\n                            var prop = propOrign;\n                            if (prop.indexOf('-') > -1) {\n                                prop = propOrign.toLowerCase().replace(/-(.)/g, function (match, group1) {\n                                    return group1.toUpperCase();\n                                });\n                            }\n                            var newValue = attrs_vars[propOrign];\n                            var regx = /(\\w*)+\\.if$/g;\n                            if (regx.test(prop)) {\n                                var attrcondi = prop.replace('.if', '');\n                                if (newValue) {\n                                    this_1[attrcondi] = attrcondi;\n                                }\n                                else {\n                                    delete this_1[attrcondi];\n                                }\n                            }\n                            else if (prop.indexOf('.') > -1) {\n                                var prop_splited = prop.split('.');\n                                if (this_1[prop_splited[0]] && typeof this_1[prop_splited[0]][prop_splited[1]] === 'function') {\n                                    this_1[prop_splited[0]][prop_splited[1]](newValue);\n                                    if (typeof this_1[prop_splited[0]]['unsubscribeAll'] === 'function') {\n                                        var compInst_1 = nodes_watched_1.default[this_1._capture$KeyId()].inst;\n                                        if (!compInst_1._$unsubs$_) {\n                                            compInst_1._$unsubs$_ = [];\n                                        }\n                                        compInst_1._$unsubs$_.push(this_1[prop_splited[0]]);\n                                        if (typeof compInst_1.afterDetached !== 'function') {\n                                            compInst_1.afterDetached = function () {\n                                                compInst_1._$unsubs$_.forEach(function (insSub) {\n                                                    insSub.unsubscribeAll();\n                                                });\n                                                this._$unsubs$_.length = 0;\n                                                delete this._$unsubs$_;\n                                            };\n                                        }\n                                    }\n                                }\n                                else {\n                                    var compName = nodes_watched_1.default[this_1._capture$KeyId()].alias;\n                                    console.warn(\"There is no method '\" + prop + \"' in component '\" + compName + \"'!\");\n                                }\n                            }\n                            else {\n                                var oldValue = this_1[prop];\n                                this_1[prop] = newValue;\n                                if (this_1.attributeChanged) {\n                                    this_1.attributeChanged(prop, oldValue, newValue);\n                                }\n                            }\n                        }\n                    }\n                };\n                var this_1 = this;\n                for (var propOrign in attrs_vars) {\n                    _loop_1(propOrign);\n                }\n            }\n        };\n        ComponentFactory.prototype.reDraw = function () {\n            var _$key$_ = this._capture$KeyId ? this._capture$KeyId() : '';\n            var _inst_ = (nodes_watched_1.default[_$key$_] || { inst: this, extStaticVars: [], extHostVars: '' });\n            _inst_.extHostVars = _inst_.extHostVars || '';\n            _inst_.extStaticVars = _inst_.extStaticVars || [];\n            _inst_.target = _inst_.target || \"uid_\" + (uid_generated++) + \"_provided\";\n            if (_inst_.extStaticVars.indexOf('id') < 0) {\n                _inst_.extStaticVars.push('id', _inst_.target);\n            }\n            else {\n                _inst_.target = _inst_.extStaticVars[_inst_.extStaticVars.indexOf('id') + 1];\n            }\n            if (_inst_.extStaticVars.indexOf('is') < 0 && _inst_.alias) {\n                _inst_.extStaticVars.push('is', _inst_.alias);\n            }\n            if (_$key$_) {\n                _inst_.extStaticVars.push('key-id', _$key$_);\n            }\n            _IDOM.elementOpen.apply(_IDOM, [_inst_.tag, _$key$_, _inst_.extStaticVars].concat(new Function('$_this_$', \"return [\" + _inst_.extHostVars + \"]\")(_inst_.inst)));\n            _inst_.inst.render(_inst_.inst);\n            _IDOM.elementClose(_inst_.tag);\n        };\n        ComponentFactory.prototype.refresh = function (props) {\n            var _$key$_ = this._capture$KeyId ? this._capture$KeyId() : '';\n            var _inst_ = nodes_watched_1.default[_$key$_] || { inst: this };\n            var shouldUpdate = true;\n            var handlerRefresh = function (propsResolved) {\n                if (_inst_.inst.shouldUpdate) {\n                    shouldUpdate = _inst_.inst.shouldUpdate(propsResolved);\n                }\n                if (shouldUpdate) {\n                    if (propsResolved && typeof propsResolved === 'object') {\n                        ComponentFactory.prototype.changeAttrs.apply(_inst_.inst, [propsResolved]);\n                    }\n                    if ((_inst_.loaded || _inst_.alias === 'compose-view') && _inst_.target && document.getElementById(_inst_.target)) {\n                        var elementDom_1 = document.getElementById(_inst_.target);\n                        if (_inst_.extHostVars && _inst_.extHostVars !== '\"\"') {\n                            var converted_to_array_1 = new Function('$_this_$', \"return [\" + _inst_.extHostVars + \"]\")(_inst_.inst);\n                            converted_to_array_1.forEach(function (attrkey, $indx) {\n                                var skypeZero = $indx || 2;\n                                if (skypeZero % 2 === 0) {\n                                    elementDom_1.setAttribute(attrkey, converted_to_array_1[$indx + 1]);\n                                }\n                            });\n                        }\n                        if (_inst_['is']) {\n                            elementDom_1.setAttribute('is', _inst_['is']);\n                        }\n                        _IDOM.patch(elementDom_1, _inst_.inst.render, _inst_.inst);\n                    }\n                }\n                return propsResolved;\n            };\n            if (props && typeof props === 'function') {\n                return handlerRefresh(props(_inst_.inst));\n            }\n            else if (props && typeof props['then'] === 'function' && typeof props['catch'] === 'function') {\n                return props\n                    .then(handlerRefresh);\n            }\n            else if (props) {\n                return handlerRefresh(props);\n            }\n            return handlerRefresh();\n        };\n        ComponentFactory.prototype.compose = function (path, target, host_vars, static_vars, contentfn) {\n            var _this = this;\n            var handlerLoad = function (mod) {\n                var _inst_ = _this.build({\n                    classFactory: mod.default,\n                    hostVars: host_vars,\n                    staticVars: static_vars,\n                    target: target,\n                    alias: 'compose-view',\n                    tag: 'div'\n                });\n                var _$key$_ = _inst_._capture$KeyId ? _inst_._capture$KeyId() : '';\n                nodes_watched_1.default[_$key$_]['is'] = path.substring(path.lastIndexOf('/') + 1, path.length);\n                ComponentFactory.prototype.content.call(nodes_watched_1.default[_$key$_], contentfn);\n                _inst_.refresh();\n                if (!nodes_watched_1.default[_$key$_].loaded) {\n                    if (_inst_.attached) {\n                        _inst_.attached(document.body.querySelector(\"[key-id=\" + _$key$_ + \"]\"));\n                    }\n                }\n                if (_$key$_ && nodes_watched_1.default[_$key$_]) {\n                    nodes_watched_1.default[_$key$_].loaded = true;\n                }\n            };\n            if (typeof __webpack_require__ === 'function') {\n                require([\"@/\" + path + this.config.templateExtension], handlerLoad.bind(this));\n            }\n            else {\n                require([\"\" + path + this.config.templateExtension], handlerLoad.bind(this));\n            }\n        };\n        return ComponentFactory;\n    }());\n    exports.ComponentFactory = ComponentFactory;\n    exports.default = new ComponentFactory();\n});\n","\n/**\n * @license\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n'use strict';\n\n/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * A cached reference to the hasOwnProperty function.\n */\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * A constructor function that will create blank objects.\n * @constructor\n */\nfunction Blank() {}\n\nBlank.prototype = Object.create(null);\n\n/**\n * Used to prevent property collisions between our \"map\" and its prototype.\n * @param {!Object<string, *>} map The map to check.\n * @param {string} property The property to check.\n * @return {boolean} Whether map has property.\n */\nvar has = function (map, property) {\n  return hasOwnProperty.call(map, property);\n};\n\n/**\n * Creates an map object without a prototype.\n * @return {!Object}\n */\nvar createMap = function () {\n  return new Blank();\n};\n\n/**\n * Keeps track of information needed to perform diffs for a given DOM node.\n * @param {!string} nodeName\n * @param {?string=} key\n * @constructor\n */\nfunction NodeData(nodeName, key) {\n  /**\n   * The attributes and their values.\n   * @const {!Object<string, *>}\n   */\n  this.attrs = createMap();\n\n  /**\n   * An array of attribute name/value pairs, used for quickly diffing the\n   * incomming attributes to see if the DOM node's attributes need to be\n   * updated.\n   * @const {Array<*>}\n   */\n  this.attrsArr = [];\n\n  /**\n   * The incoming attributes for this Node, before they are updated.\n   * @const {!Object<string, *>}\n   */\n  this.newAttrs = createMap();\n\n  /**\n   * Whether or not the statics have been applied for the node yet.\n   * {boolean}\n   */\n  this.staticsApplied = false;\n\n  /**\n   * The key used to identify this node, used to preserve DOM nodes when they\n   * move within their parent.\n   * @const\n   */\n  this.key = key;\n\n  /**\n   * Keeps track of children within this node by their key.\n   * {!Object<string, !Element>}\n   */\n  this.keyMap = createMap();\n\n  /**\n   * Whether or not the keyMap is currently valid.\n   * @type {boolean}\n   */\n  this.keyMapValid = true;\n\n  /**\n   * Whether or the associated node is, or contains, a focused Element.\n   * @type {boolean}\n   */\n  this.focused = false;\n\n  /**\n   * The node name for this node.\n   * @const {string}\n   */\n  this.nodeName = nodeName;\n\n  /**\n   * @type {?string}\n   */\n  this.text = null;\n}\n\n/**\n * Initializes a NodeData object for a Node.\n *\n * @param {Node} node The node to initialize data for.\n * @param {string} nodeName The node name of node.\n * @param {?string=} key The key that identifies the node.\n * @return {!NodeData} The newly initialized data object\n */\nvar initData = function (node, nodeName, key) {\n  var data = new NodeData(nodeName, key);\n  node['__incrementalDOMData'] = data;\n  return data;\n};\n\n/**\n * Retrieves the NodeData object for a Node, creating it if necessary.\n *\n * @param {?Node} node The Node to retrieve the data for.\n * @return {!NodeData} The NodeData for this Node.\n */\nvar getData = function (node) {\n  importNode(node);\n  return node['__incrementalDOMData'];\n};\n\n/**\n * Imports node and its subtree, initializing caches.\n *\n * @param {?Node} node The Node to import.\n */\nvar importNode = function (node) {\n  if (node['__incrementalDOMData']) {\n    return;\n  }\n\n  var isElement = node instanceof Element;\n  var nodeName = isElement ? node.localName : node.nodeName;\n  var key = isElement ? node.getAttribute('key') : null;\n  var data = initData(node, nodeName, key);\n\n  if (key) {\n    getData(node.parentNode).keyMap[key] = node;\n  }\n\n  if (isElement) {\n    var attributes = node.attributes;\n    var attrs = data.attrs;\n    var newAttrs = data.newAttrs;\n    var attrsArr = data.attrsArr;\n\n    for (var i = 0; i < attributes.length; i += 1) {\n      var attr = attributes[i];\n      var name = attr.name;\n      var value = attr.value;\n\n      attrs[name] = value;\n      newAttrs[name] = undefined;\n      attrsArr.push(name);\n      attrsArr.push(value);\n    }\n  }\n\n  for (var child = node.firstChild; child; child = child.nextSibling) {\n    importNode(child);\n  }\n};\n\n/**\n * Gets the namespace to create an element (of a given tag) in.\n * @param {string} tag The tag to get the namespace for.\n * @param {?Node} parent\n * @return {?string} The namespace to create the tag in.\n */\nvar getNamespaceForTag = function (tag, parent) {\n  if (tag === 'svg') {\n    return 'http://www.w3.org/2000/svg';\n  }\n\n  if (getData(parent).nodeName === 'foreignObject') {\n    return null;\n  }\n\n  return parent.namespaceURI;\n};\n\n/**\n * Creates an Element.\n * @param {Document} doc The document with which to create the Element.\n * @param {?Node} parent\n * @param {string} tag The tag for the Element.\n * @param {?string=} key A key to identify the Element.\n * @return {!Element}\n */\nvar createElement = function (doc, parent, tag, key) {\n  var namespace = getNamespaceForTag(tag, parent);\n  var el = undefined;\n\n  if (namespace) {\n    el = doc.createElementNS(namespace, tag);\n  } else {\n    el = doc.createElement(tag);\n  }\n\n  initData(el, tag, key);\n\n  return el;\n};\n\n/**\n * Creates a Text Node.\n * @param {Document} doc The document with which to create the Element.\n * @return {!Text}\n */\nvar createText = function (doc) {\n  var node = doc.createTextNode('');\n  initData(node, '#text', null);\n  return node;\n};\n\n/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** @const */\nvar notifications = {\n  /**\n   * Called after patch has compleated with any Nodes that have been created\n   * and added to the DOM.\n   * @type {?function(Array<!Node>)}\n   */\n  nodesCreated: null,\n\n  /**\n   * Called after patch has compleated with any Nodes that have been removed\n   * from the DOM.\n   * Note it's an applications responsibility to handle any childNodes.\n   * @type {?function(Array<!Node>)}\n   */\n  nodesDeleted: null\n};\n\n/**\n * Keeps track of the state of a patch.\n * @constructor\n */\nfunction Context() {\n  /**\n   * @type {(Array<!Node>|undefined)}\n   */\n  this.created = notifications.nodesCreated && [];\n\n  /**\n   * @type {(Array<!Node>|undefined)}\n   */\n  this.deleted = notifications.nodesDeleted && [];\n}\n\n/**\n * @param {!Node} node\n */\nContext.prototype.markCreated = function (node) {\n  if (this.created) {\n    this.created.push(node);\n  }\n};\n\n/**\n * @param {!Node} node\n */\nContext.prototype.markDeleted = function (node) {\n  if (this.deleted) {\n    this.deleted.push(node);\n  }\n};\n\n/**\n * Notifies about nodes that were created during the patch opearation.\n */\nContext.prototype.notifyChanges = function () {\n  if (this.created && this.created.length > 0) {\n    notifications.nodesCreated(this.created);\n  }\n\n  if (this.deleted && this.deleted.length > 0) {\n    notifications.nodesDeleted(this.deleted);\n  }\n};\n\n/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n  * Keeps track whether or not we are in an attributes declaration (after\n  * elementOpenStart, but before elementOpenEnd).\n  * @type {boolean}\n  */\nvar inAttributes = false;\n\n/**\n  * Keeps track whether or not we are in an element that should not have its\n  * children cleared.\n  * @type {boolean}\n  */\nvar inSkip = false;\n\n/**\n * Makes sure that there is a current patch context.\n * @param {string} functionName\n * @param {*} context\n */\nvar assertInPatch = function (functionName, context) {\n  if (!context) {\n    throw new Error('Cannot call ' + functionName + '() unless in patch.');\n  }\n};\n\n/**\n * Makes sure that a patch closes every node that it opened.\n * @param {?Node} openElement\n * @param {!Node|!DocumentFragment} root\n */\nvar assertNoUnclosedTags = function (openElement, root) {\n  if (openElement === root) {\n    return;\n  }\n\n  var currentElement = openElement;\n  var openTags = [];\n  while (currentElement && currentElement !== root) {\n    openTags.push(currentElement.nodeName.toLowerCase());\n    currentElement = currentElement.parentNode;\n  }\n\n  throw new Error('One or more tags were not closed:\\n' + openTags.join('\\n'));\n};\n\n/**\n * Makes sure that the caller is not where attributes are expected.\n * @param {string} functionName\n */\nvar assertNotInAttributes = function (functionName) {\n  if (inAttributes) {\n    throw new Error(functionName + '() can not be called between ' + 'elementOpenStart() and elementOpenEnd().');\n  }\n};\n\n/**\n * Makes sure that the caller is not inside an element that has declared skip.\n * @param {string} functionName\n */\nvar assertNotInSkip = function (functionName) {\n  if (inSkip) {\n    throw new Error(functionName + '() may not be called inside an element ' + 'that has called skip().');\n  }\n};\n\n/**\n * Makes sure that the caller is where attributes are expected.\n * @param {string} functionName\n */\nvar assertInAttributes = function (functionName) {\n  if (!inAttributes) {\n    throw new Error(functionName + '() can only be called after calling ' + 'elementOpenStart().');\n  }\n};\n\n/**\n * Makes sure the patch closes virtual attributes call\n */\nvar assertVirtualAttributesClosed = function () {\n  if (inAttributes) {\n    throw new Error('elementOpenEnd() must be called after calling ' + 'elementOpenStart().');\n  }\n};\n\n/**\n  * Makes sure that tags are correctly nested.\n  * @param {string} nodeName\n  * @param {string} tag\n  */\nvar assertCloseMatchesOpenTag = function (nodeName, tag) {\n  if (nodeName !== tag) {\n    throw new Error('Received a call to close \"' + tag + '\" but \"' + nodeName + '\" was open.');\n  }\n};\n\n/**\n * Makes sure that no children elements have been declared yet in the current\n * element.\n * @param {string} functionName\n * @param {?Node} previousNode\n */\nvar assertNoChildrenDeclaredYet = function (functionName, previousNode) {\n  if (previousNode !== null) {\n    throw new Error(functionName + '() must come before any child ' + 'declarations inside the current element.');\n  }\n};\n\n/**\n * Checks that a call to patchOuter actually patched the element.\n * @param {?Node} startNode The value for the currentNode when the patch\n *     started.\n * @param {?Node} currentNode The currentNode when the patch finished.\n * @param {?Node} expectedNextNode The Node that is expected to follow the\n *    currentNode after the patch;\n * @param {?Node} expectedPrevNode The Node that is expected to preceed the\n *    currentNode after the patch.\n */\nvar assertPatchElementNoExtras = function (startNode, currentNode, expectedNextNode, expectedPrevNode) {\n  var wasUpdated = currentNode.nextSibling === expectedNextNode && currentNode.previousSibling === expectedPrevNode;\n  var wasChanged = currentNode.nextSibling === startNode.nextSibling && currentNode.previousSibling === expectedPrevNode;\n  var wasRemoved = currentNode === startNode;\n\n  if (!wasUpdated && !wasChanged && !wasRemoved) {\n    throw new Error('There must be exactly one top level call corresponding ' + 'to the patched element.');\n  }\n};\n\n/**\n * Updates the state of being in an attribute declaration.\n * @param {boolean} value\n * @return {boolean} the previous value.\n */\nvar setInAttributes = function (value) {\n  var previous = inAttributes;\n  inAttributes = value;\n  return previous;\n};\n\n/**\n * Updates the state of being in a skip element.\n * @param {boolean} value\n * @return {boolean} the previous value.\n */\nvar setInSkip = function (value) {\n  var previous = inSkip;\n  inSkip = value;\n  return previous;\n};\n\n/**\n * Copyright 2016 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @param {!Node} node\n * @return {boolean} True if the node the root of a document, false otherwise.\n */\nvar isDocumentRoot = function (node) {\n  // For ShadowRoots, check if they are a DocumentFragment instead of if they\n  // are a ShadowRoot so that this can work in 'use strict' if ShadowRoots are\n  // not supported.\n  return node instanceof Document || node instanceof DocumentFragment;\n};\n\n/**\n * @param {!Node} node The node to start at, inclusive.\n * @param {?Node} root The root ancestor to get until, exclusive.\n * @return {!Array<!Node>} The ancestry of DOM nodes.\n */\nvar getAncestry = function (node, root) {\n  var ancestry = [];\n  var cur = node;\n\n  while (cur !== root) {\n    ancestry.push(cur);\n    cur = cur.parentNode;\n  }\n\n  return ancestry;\n};\n\n/**\n * @param {!Node} node\n * @return {!Node} The root node of the DOM tree that contains node.\n */\nvar getRoot = function (node) {\n  var cur = node;\n  var prev = cur;\n\n  while (cur) {\n    prev = cur;\n    cur = cur.parentNode;\n  }\n\n  return prev;\n};\n\n/**\n * @param {!Node} node The node to get the activeElement for.\n * @return {?Element} The activeElement in the Document or ShadowRoot\n *     corresponding to node, if present.\n */\nvar getActiveElement = function (node) {\n  var root = getRoot(node);\n  return isDocumentRoot(root) ? root.activeElement : null;\n};\n\n/**\n * Gets the path of nodes that contain the focused node in the same document as\n * a reference node, up until the root.\n * @param {!Node} node The reference node to get the activeElement for.\n * @param {?Node} root The root to get the focused path until.\n * @return {!Array<Node>}\n */\nvar getFocusedPath = function (node, root) {\n  var activeElement = getActiveElement(node);\n\n  if (!activeElement || !node.contains(activeElement)) {\n    return [];\n  }\n\n  return getAncestry(activeElement, root);\n};\n\n/**\n * Like insertBefore, but instead instead of moving the desired node, instead\n * moves all the other nodes after.\n * @param {?Node} parentNode\n * @param {!Node} node\n * @param {?Node} referenceNode\n */\nvar moveBefore = function (parentNode, node, referenceNode) {\n  var insertReferenceNode = node.nextSibling;\n  var cur = referenceNode;\n\n  while (cur !== node) {\n    var next = cur.nextSibling;\n    parentNode.insertBefore(cur, insertReferenceNode);\n    cur = next;\n  }\n};\n\n/** @type {?Context} */\nvar context = null;\n\n/** @type {?Node} */\nvar currentNode = null;\n\n/** @type {?Node} */\nvar currentParent = null;\n\n/** @type {?Document} */\nvar doc = null;\n\n/**\n * @param {!Array<Node>} focusPath The nodes to mark.\n * @param {boolean} focused Whether or not they are focused.\n */\nvar markFocused = function (focusPath, focused) {\n  for (var i = 0; i < focusPath.length; i += 1) {\n    getData(focusPath[i]).focused = focused;\n  }\n};\n\n/**\n * Returns a patcher function that sets up and restores a patch context,\n * running the run function with the provided data.\n * @param {function((!Element|!DocumentFragment),!function(T),T=): ?Node} run\n * @return {function((!Element|!DocumentFragment),!function(T),T=): ?Node}\n * @template T\n */\nvar patchFactory = function (run) {\n  /**\n   * TODO(moz): These annotations won't be necessary once we switch to Closure\n   * Compiler's new type inference. Remove these once the switch is done.\n   *\n   * @param {(!Element|!DocumentFragment)} node\n   * @param {!function(T)} fn\n   * @param {T=} data\n   * @return {?Node} node\n   * @template T\n   */\n  var f = function (node, fn, data) {\n    var prevContext = context;\n    var prevDoc = doc;\n    var prevCurrentNode = currentNode;\n    var prevCurrentParent = currentParent;\n    var previousInAttributes = false;\n    var previousInSkip = false;\n\n    context = new Context();\n    doc = node.ownerDocument;\n    currentParent = node.parentNode;\n\n    if (process.env.NODE_ENV !== 'production') {\n      previousInAttributes = setInAttributes(false);\n      previousInSkip = setInSkip(false);\n    }\n\n    var focusPath = getFocusedPath(node, currentParent);\n    markFocused(focusPath, true);\n    var retVal = run(node, fn, data);\n    markFocused(focusPath, false);\n\n    if (process.env.NODE_ENV !== 'production') {\n      assertVirtualAttributesClosed();\n      setInAttributes(previousInAttributes);\n      setInSkip(previousInSkip);\n    }\n\n    context.notifyChanges();\n\n    context = prevContext;\n    doc = prevDoc;\n    currentNode = prevCurrentNode;\n    currentParent = prevCurrentParent;\n\n    return retVal;\n  };\n  return f;\n};\n\n/**\n * Patches the document starting at node with the provided function. This\n * function may be called during an existing patch operation.\n * @param {!Element|!DocumentFragment} node The Element or Document\n *     to patch.\n * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.\n *     calls that describe the DOM.\n * @param {T=} data An argument passed to fn to represent DOM state.\n * @return {!Node} The patched node.\n * @template T\n */\nvar patchInner = patchFactory(function (node, fn, data) {\n  currentNode = node;\n\n  enterNode();\n  fn(data);\n  exitNode();\n\n  if (process.env.NODE_ENV !== 'production') {\n    assertNoUnclosedTags(currentNode, node);\n  }\n\n  return node;\n});\n\n/**\n * Patches an Element with the the provided function. Exactly one top level\n * element call should be made corresponding to `node`.\n * @param {!Element} node The Element where the patch should start.\n * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.\n *     calls that describe the DOM. This should have at most one top level\n *     element call.\n * @param {T=} data An argument passed to fn to represent DOM state.\n * @return {?Node} The node if it was updated, its replacedment or null if it\n *     was removed.\n * @template T\n */\nvar patchOuter = patchFactory(function (node, fn, data) {\n  var startNode = /** @type {!Element} */{ nextSibling: node };\n  var expectedNextNode = null;\n  var expectedPrevNode = null;\n\n  if (process.env.NODE_ENV !== 'production') {\n    expectedNextNode = node.nextSibling;\n    expectedPrevNode = node.previousSibling;\n  }\n\n  currentNode = startNode;\n  fn(data);\n\n  if (process.env.NODE_ENV !== 'production') {\n    assertPatchElementNoExtras(startNode, currentNode, expectedNextNode, expectedPrevNode);\n  }\n\n  if (node !== currentNode && node.parentNode) {\n    removeChild(currentParent, node, getData(currentParent).keyMap);\n  }\n\n  return startNode === currentNode ? null : currentNode;\n});\n\n/**\n * Checks whether or not the current node matches the specified nodeName and\n * key.\n *\n * @param {!Node} matchNode A node to match the data to.\n * @param {?string} nodeName The nodeName for this node.\n * @param {?string=} key An optional key that identifies a node.\n * @return {boolean} True if the node matches, false otherwise.\n */\nvar matches = function (matchNode, nodeName, key) {\n  var data = getData(matchNode);\n\n  // Key check is done using double equals as we want to treat a null key the\n  // same as undefined. This should be okay as the only values allowed are\n  // strings, null and undefined so the == semantics are not too weird.\n  return nodeName === data.nodeName && key == data.key;\n};\n\n/**\n * Aligns the virtual Element definition with the actual DOM, moving the\n * corresponding DOM node to the correct location or creating it if necessary.\n * @param {string} nodeName For an Element, this should be a valid tag string.\n *     For a Text, this should be #text.\n * @param {?string=} key The key used to identify this element.\n */\nvar alignWithDOM = function (nodeName, key) {\n  if (currentNode && matches(currentNode, nodeName, key)) {\n    return;\n  }\n\n  var parentData = getData(currentParent);\n  var currentNodeData = currentNode && getData(currentNode);\n  var keyMap = parentData.keyMap;\n  var node = undefined;\n\n  // Check to see if the node has moved within the parent.\n  if (key) {\n    var keyNode = keyMap[key];\n    if (keyNode) {\n      if (matches(keyNode, nodeName, key)) {\n        node = keyNode;\n      } else if (keyNode === currentNode) {\n        context.markDeleted(keyNode);\n      } else {\n        removeChild(currentParent, keyNode, keyMap);\n      }\n    }\n  }\n\n  // Create the node if it doesn't exist.\n  if (!node) {\n    if (nodeName === '#text') {\n      node = createText(doc);\n    } else {\n      node = createElement(doc, currentParent, nodeName, key);\n    }\n\n    if (key) {\n      keyMap[key] = node;\n    }\n\n    context.markCreated(node);\n  }\n\n  // Re-order the node into the right position, preserving focus if either\n  // node or currentNode are focused by making sure that they are not detached\n  // from the DOM.\n  if (getData(node).focused) {\n    // Move everything else before the node.\n    moveBefore(currentParent, node, currentNode);\n  } else if (currentNodeData && currentNodeData.key && !currentNodeData.focused) {\n    // Remove the currentNode, which can always be added back since we hold a\n    // reference through the keyMap. This prevents a large number of moves when\n    // a keyed item is removed or moved backwards in the DOM.\n    currentParent.replaceChild(node, currentNode);\n    parentData.keyMapValid = false;\n  } else {\n    currentParent.insertBefore(node, currentNode);\n  }\n\n  currentNode = node;\n};\n\n/**\n * @param {?Node} node\n * @param {?Node} child\n * @param {?Object<string, !Element>} keyMap\n */\nvar removeChild = function (node, child, keyMap) {\n  node.removeChild(child);\n  context.markDeleted( /** @type {!Node}*/child);\n\n  var key = getData(child).key;\n  if (key) {\n    delete keyMap[key];\n  }\n};\n\n/**\n * Clears out any unvisited Nodes, as the corresponding virtual element\n * functions were never called for them.\n */\nvar clearUnvisitedDOM = function () {\n  var node = currentParent;\n  var data = getData(node);\n  var keyMap = data.keyMap;\n  var keyMapValid = data.keyMapValid;\n  var child = node.lastChild;\n  var key = undefined;\n\n  if (child === currentNode && keyMapValid) {\n    return;\n  }\n\n  while (child !== currentNode) {\n    removeChild(node, child, keyMap);\n    child = node.lastChild;\n  }\n\n  // Clean the keyMap, removing any unusued keys.\n  if (!keyMapValid) {\n    for (key in keyMap) {\n      child = keyMap[key];\n      if (child.parentNode !== node) {\n        context.markDeleted(child);\n        delete keyMap[key];\n      }\n    }\n\n    data.keyMapValid = true;\n  }\n};\n\n/**\n * Changes to the first child of the current node.\n */\nvar enterNode = function () {\n  currentParent = currentNode;\n  currentNode = null;\n};\n\n/**\n * @return {?Node} The next Node to be patched.\n */\nvar getNextNode = function () {\n  if (currentNode) {\n    return currentNode.nextSibling;\n  } else {\n    return currentParent.firstChild;\n  }\n};\n\n/**\n * Changes to the next sibling of the current node.\n */\nvar nextNode = function () {\n  currentNode = getNextNode();\n};\n\n/**\n * Changes to the parent of the current node, removing any unvisited children.\n */\nvar exitNode = function () {\n  clearUnvisitedDOM();\n\n  currentNode = currentParent;\n  currentParent = currentParent.parentNode;\n};\n\n/**\n * Makes sure that the current node is an Element with a matching tagName and\n * key.\n *\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @return {!Element} The corresponding Element.\n */\nvar coreElementOpen = function (tag, key) {\n  nextNode();\n  alignWithDOM(tag, key);\n  enterNode();\n  return (/** @type {!Element} */currentParent\n  );\n};\n\n/**\n * Closes the currently open Element, removing any unvisited children if\n * necessary.\n *\n * @return {!Element} The corresponding Element.\n */\nvar coreElementClose = function () {\n  if (process.env.NODE_ENV !== 'production') {\n    setInSkip(false);\n  }\n\n  exitNode();\n  return (/** @type {!Element} */currentNode\n  );\n};\n\n/**\n * Makes sure the current node is a Text node and creates a Text node if it is\n * not.\n *\n * @return {!Text} The corresponding Text Node.\n */\nvar coreText = function () {\n  nextNode();\n  alignWithDOM('#text', null);\n  return (/** @type {!Text} */currentNode\n  );\n};\n\n/**\n * Gets the current Element being patched.\n * @return {!Element}\n */\nvar currentElement = function () {\n  if (process.env.NODE_ENV !== 'production') {\n    assertInPatch('currentElement', context);\n    assertNotInAttributes('currentElement');\n  }\n  return (/** @type {!Element} */currentParent\n  );\n};\n\n/**\n * @return {Node} The Node that will be evaluated for the next instruction.\n */\nvar currentPointer = function () {\n  if (process.env.NODE_ENV !== 'production') {\n    assertInPatch('currentPointer', context);\n    assertNotInAttributes('currentPointer');\n  }\n  return getNextNode();\n};\n\n/**\n * Skips the children in a subtree, allowing an Element to be closed without\n * clearing out the children.\n */\nvar skip = function () {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNoChildrenDeclaredYet('skip', currentNode);\n    setInSkip(true);\n  }\n  currentNode = currentParent.lastChild;\n};\n\n/**\n * Skips the next Node to be patched, moving the pointer forward to the next\n * sibling of the current pointer.\n */\nvar skipNode = nextNode;\n\n/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** @const */\nvar symbols = {\n  default: '__default'\n};\n\n/**\n * @param {string} name\n * @return {string|undefined} The namespace to use for the attribute.\n */\nvar getNamespace = function (name) {\n  if (name.lastIndexOf('xml:', 0) === 0) {\n    return 'http://www.w3.org/XML/1998/namespace';\n  }\n\n  if (name.lastIndexOf('xlink:', 0) === 0) {\n    return 'http://www.w3.org/1999/xlink';\n  }\n};\n\n/**\n * Applies an attribute or property to a given Element. If the value is null\n * or undefined, it is removed from the Element. Otherwise, the value is set\n * as an attribute.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {?(boolean|number|string)=} value The attribute's value.\n */\nvar applyAttr = function (el, name, value) {\n  if (value == null) {\n    el.removeAttribute(name);\n  } else {\n    var attrNS = getNamespace(name);\n    if (attrNS) {\n      el.setAttributeNS(attrNS, name, value);\n    } else {\n      el.setAttribute(name, value);\n    }\n  }\n};\n\n/**\n * Applies a property to a given Element.\n * @param {!Element} el\n * @param {string} name The property's name.\n * @param {*} value The property's value.\n */\nvar applyProp = function (el, name, value) {\n  el[name] = value;\n};\n\n/**\n * Applies a value to a style declaration. Supports CSS custom properties by\n * setting properties containing a dash using CSSStyleDeclaration.setProperty.\n * @param {CSSStyleDeclaration} style\n * @param {!string} prop\n * @param {*} value\n */\nvar setStyleValue = function (style, prop, value) {\n  if (prop.indexOf('-') >= 0) {\n    style.setProperty(prop, /** @type {string} */value);\n  } else {\n    style[prop] = value;\n  }\n};\n\n/**\n * Applies a style to an Element. No vendor prefix expansion is done for\n * property names/values.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} style The style to set. Either a string of css or an object\n *     containing property-value pairs.\n */\nvar applyStyle = function (el, name, style) {\n  if (typeof style === 'string') {\n    el.style.cssText = style;\n  } else {\n    el.style.cssText = '';\n    var elStyle = el.style;\n    var obj = /** @type {!Object<string,string>} */style;\n\n    for (var prop in obj) {\n      if (has(obj, prop)) {\n        setStyleValue(elStyle, prop, obj[prop]);\n      }\n    }\n  }\n};\n\n/**\n * Updates a single attribute on an Element.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} value The attribute's value. If the value is an object or\n *     function it is set on the Element, otherwise, it is set as an HTML\n *     attribute.\n */\nvar applyAttributeTyped = function (el, name, value) {\n  var type = typeof value;\n\n  if (type === 'object' || type === 'function') {\n    applyProp(el, name, value);\n  } else {\n    applyAttr(el, name, /** @type {?(boolean|number|string)} */value);\n  }\n};\n\n/**\n * Calls the appropriate attribute mutator for this attribute.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} value The attribute's value.\n */\nvar updateAttribute = function (el, name, value) {\n  var data = getData(el);\n  var attrs = data.attrs;\n\n  if (attrs[name] === value) {\n    return;\n  }\n\n  var mutator = attributes[name] || attributes[symbols.default];\n  mutator(el, name, value);\n\n  attrs[name] = value;\n};\n\n/**\n * A publicly mutable object to provide custom mutators for attributes.\n * @const {!Object<string, function(!Element, string, *)>}\n */\nvar attributes = createMap();\n\n// Special generic mutator that's called for any attribute that does not\n// have a specific mutator.\nattributes[symbols.default] = applyAttributeTyped;\n\nattributes['style'] = applyStyle;\n\n/**\n * The offset in the virtual element declaration where the attributes are\n * specified.\n * @const\n */\nvar ATTRIBUTES_OFFSET = 3;\n\n/**\n * Builds an array of arguments for use with elementOpenStart, attr and\n * elementOpenEnd.\n * @const {Array<*>}\n */\nvar argsBuilder = [];\n\n/**\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} var_args, Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nvar elementOpen = function (tag, key, statics, var_args) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNotInAttributes('elementOpen');\n    assertNotInSkip('elementOpen');\n  }\n\n  var node = coreElementOpen(tag, key);\n  var data = getData(node);\n\n  if (!data.staticsApplied) {\n    if (statics) {\n      for (var _i = 0; _i < statics.length; _i += 2) {\n        var name = /** @type {string} */statics[_i];\n        var value = statics[_i + 1];\n        updateAttribute(node, name, value);\n      }\n    }\n    // Down the road, we may want to keep track of the statics array to use it\n    // as an additional signal about whether a node matches or not. For now,\n    // just use a marker so that we do not reapply statics.\n    data.staticsApplied = true;\n  }\n\n  /*\n   * Checks to see if one or more attributes have changed for a given Element.\n   * When no attributes have changed, this is much faster than checking each\n   * individual argument. When attributes have changed, the overhead of this is\n   * minimal.\n   */\n  var attrsArr = data.attrsArr;\n  var newAttrs = data.newAttrs;\n  var isNew = !attrsArr.length;\n  var i = ATTRIBUTES_OFFSET;\n  var j = 0;\n\n  for (; i < arguments.length; i += 2, j += 2) {\n    var _attr = arguments[i];\n    if (isNew) {\n      attrsArr[j] = _attr;\n      newAttrs[_attr] = undefined;\n    } else if (attrsArr[j] !== _attr) {\n      break;\n    }\n\n    var value = arguments[i + 1];\n    if (isNew || attrsArr[j + 1] !== value) {\n      attrsArr[j + 1] = value;\n      updateAttribute(node, _attr, value);\n    }\n  }\n\n  if (i < arguments.length || j < attrsArr.length) {\n    for (; i < arguments.length; i += 1, j += 1) {\n      attrsArr[j] = arguments[i];\n    }\n\n    if (j < attrsArr.length) {\n      attrsArr.length = j;\n    }\n\n    /*\n     * Actually perform the attribute update.\n     */\n    for (i = 0; i < attrsArr.length; i += 2) {\n      var name = /** @type {string} */attrsArr[i];\n      var value = attrsArr[i + 1];\n      newAttrs[name] = value;\n    }\n\n    for (var _attr2 in newAttrs) {\n      updateAttribute(node, _attr2, newAttrs[_attr2]);\n      newAttrs[_attr2] = undefined;\n    }\n  }\n\n  return node;\n};\n\n/**\n * Declares a virtual Element at the current location in the document. This\n * corresponds to an opening tag and a elementClose tag is required. This is\n * like elementOpen, but the attributes are defined using the attr function\n * rather than being passed as arguments. Must be folllowed by 0 or more calls\n * to attr, then a call to elementOpenEnd.\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n */\nvar elementOpenStart = function (tag, key, statics) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNotInAttributes('elementOpenStart');\n    setInAttributes(true);\n  }\n\n  argsBuilder[0] = tag;\n  argsBuilder[1] = key;\n  argsBuilder[2] = statics;\n};\n\n/***\n * Defines a virtual attribute at this point of the DOM. This is only valid\n * when called between elementOpenStart and elementOpenEnd.\n *\n * @param {string} name\n * @param {*} value\n */\nvar attr = function (name, value) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertInAttributes('attr');\n  }\n\n  argsBuilder.push(name);\n  argsBuilder.push(value);\n};\n\n/**\n * Closes an open tag started with elementOpenStart.\n * @return {!Element} The corresponding Element.\n */\nvar elementOpenEnd = function () {\n  if (process.env.NODE_ENV !== 'production') {\n    assertInAttributes('elementOpenEnd');\n    setInAttributes(false);\n  }\n\n  var node = elementOpen.apply(null, argsBuilder);\n  argsBuilder.length = 0;\n  return node;\n};\n\n/**\n * Closes an open virtual Element.\n *\n * @param {string} tag The element's tag.\n * @return {!Element} The corresponding Element.\n */\nvar elementClose = function (tag) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNotInAttributes('elementClose');\n  }\n\n  var node = coreElementClose();\n\n  if (process.env.NODE_ENV !== 'production') {\n    assertCloseMatchesOpenTag(getData(node).nodeName, tag);\n  }\n\n  return node;\n};\n\n/**\n * Declares a virtual Element at the current location in the document that has\n * no children.\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nvar elementVoid = function (tag, key, statics, var_args) {\n  elementOpen.apply(null, arguments);\n  return elementClose(tag);\n};\n\n/**\n * Declares a virtual Text at this point in the document.\n *\n * @param {string|number|boolean} value The value of the Text.\n * @param {...(function((string|number|boolean)):string)} var_args\n *     Functions to format the value which are called only when the value has\n *     changed.\n * @return {!Text} The corresponding text node.\n */\nvar text = function (value, var_args) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNotInAttributes('text');\n    assertNotInSkip('text');\n  }\n\n  var node = coreText();\n  var data = getData(node);\n\n  if (data.text !== value) {\n    data.text = /** @type {string} */value;\n\n    var formatted = value;\n    for (var i = 1; i < arguments.length; i += 1) {\n      /*\n       * Call the formatter function directly to prevent leaking arguments.\n       * https://github.com/google/incremental-dom/pull/204#issuecomment-178223574\n       */\n      var fn = arguments[i];\n      formatted = fn(formatted);\n    }\n\n    node.data = formatted;\n  }\n\n  return node;\n};\n\nexports.patch = patchInner;\nexports.patchInner = patchInner;\nexports.patchOuter = patchOuter;\nexports.currentElement = currentElement;\nexports.currentPointer = currentPointer;\nexports.skip = skip;\nexports.skipNode = skipNode;\nexports.elementVoid = elementVoid;\nexports.elementOpenStart = elementOpenStart;\nexports.elementOpenEnd = elementOpenEnd;\nexports.elementOpen = elementOpen;\nexports.elementClose = elementClose;\nexports.text = text;\nexports.attr = attr;\nexports.symbols = symbols;\nexports.attributes = attributes;\nexports.applyAttr = applyAttr;\nexports.applyProp = applyProp;\nexports.notifications = notifications;\nexports.importNode = importNode;\n\n//# sourceMappingURL=incremental-dom-cjs.js.map","define([\"require\", \"exports\"], function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var inst_watched = {};\n    exports.default = inst_watched;\n});\n","define([\"require\", \"exports\", \"incremental-dom\", \"./component-factory\"], function (require, exports, _IDOM, component_factory_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var PlatformBootstrap = (function () {\n        function PlatformBootstrap() {\n        }\n        PlatformBootstrap.prototype.bootstrap = function (pmodule, option) {\n            this._module = pmodule;\n            component_factory_1.default.config.templateExtension = option && option.templateExtension ? option.templateExtension : '.html';\n            return this;\n        };\n        PlatformBootstrap.prototype.at = function (domRender) {\n            var app_uid = domRender.getAttribute('id');\n            if (!app_uid) {\n                app_uid = \"uid_\" + new Date().getTime();\n                domRender.setAttribute('id', app_uid);\n            }\n            var _tmp_inst = component_factory_1.default.build({\n                classFactory: this._module.default,\n                staticVars: {\n                    'key:id': app_uid\n                },\n                hostVars: {},\n                tag: 'div',\n                alias: 'init-app-tag'\n            });\n            _IDOM.patch(document.getElementById(app_uid), component_factory_1.default.reDraw.bind(_tmp_inst), _tmp_inst);\n            delete this._module;\n        };\n        return PlatformBootstrap;\n    }());\n    exports.PlatformBootstrap = PlatformBootstrap;\n    exports.default = new PlatformBootstrap();\n});\n","import { bootstrapper } from \"ferrugemjs\";\nbootstrapper();","define([\"require\", \"exports\", \"./component-factory\", \"./platform\", \"./bootstrapper\"], function (require, exports, component_factory_1, platform_1, bootstrapper_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.componentFactory = component_factory_1.default;\n    exports.platform = platform_1.default;\n    exports.bootstrapper = bootstrapper_1.default;\n});\n","define([\"require\", \"exports\", \"./nodes-watched\"], function (require, exports, nodes_watched_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.detacheNode = function (node) {\n        if (node.children && node.children.length) {\n            var node_array = Array.prototype.slice.call(node.children);\n            node_array.forEach(exports.detacheNode);\n        }\n        var key_id = node.getAttribute ? node.getAttribute('key-id') : '';\n        var inst_captured = nodes_watched_1.default[key_id];\n        if (key_id && inst_captured) {\n            if (inst_captured.inst.detached) {\n                inst_captured.inst.detached();\n            }\n            if (inst_captured.inst.afterDetached) {\n                inst_captured.inst.afterDetached();\n            }\n        }\n        if (key_id && inst_captured) {\n            inst_captured.inst._capture$KeyId = null;\n            delete inst_captured.inst._capture$KeyId;\n            inst_captured.loaded = false;\n            inst_captured.inst = null;\n            inst_captured = null;\n            delete nodes_watched_1.default[key_id];\n        }\n    };\n    exports.attacheNode = function (node) {\n        var key_id = node.getAttribute ? node.getAttribute('key-id') : '';\n        var inst_captured = nodes_watched_1.default[key_id];\n        if (key_id && inst_captured) {\n            if (!inst_captured.loaded) {\n                if (inst_captured.inst.attached) {\n                    inst_captured.inst.attached(node);\n                }\n            }\n            inst_captured.loaded = true;\n        }\n    };\n});\n","define([\"require\", \"exports\", \"./platform\"], function (require, exports, platform_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.default = (function () {\n        var app_html_s = document.querySelectorAll('[app]');\n        var app_html;\n        if (app_html_s.length === 0) {\n            app_html = document.getElementsByTagName('body')[0];\n        }\n        else {\n            app_html = app_html_s[0];\n        }\n        app_html_s = null;\n        var app_url = app_html.getAttribute('app') || 'app';\n        var templateExtension = app_html.getAttribute('template-extension') || '.html';\n        if (typeof __webpack_require__ === 'function') {\n            require([\"@/\" + app_url + templateExtension], function (_mod_init_app) {\n                platform_1.default\n                    .bootstrap(_mod_init_app, { templateExtension: templateExtension })\n                    .at(app_html);\n            });\n        }\n        else {\n            require([\"\" + app_url + templateExtension], function (_mod_init_app) {\n                platform_1.default\n                    .bootstrap(_mod_init_app, { templateExtension: templateExtension })\n                    .at(app_html);\n            });\n        }\n    });\n});\n"],"sourceRoot":""}